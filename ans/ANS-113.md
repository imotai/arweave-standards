# ANS-113: Appendable Log File v1.0

Status: draft

## Abstract

This document describes a appendable log file with the following parts

* How to open Log File
* How to append data to the Log File
* How to read the Log File
* How to keep security

## Motivation

Building a appendable log file format will provides the following benefits:
The developer can append data to a single file at any time without any external meta

## Reference Implementation

There is a reference implementation for the creation, signing, and verification of DataItems and working with bundles
in [TypeScript](https://github.com/ArweaveTeam/arweave-data)

## Specification

### 1. Transaction Format

#### 1.1 Transaction Tags

The Log format MUST have the following four tags present:

- `Log-Format` a string describing the bundling format. The format for this standard is `ar-log`
- `Log-Version` a version string. The version referred to in this standard is `1.0.0`
- `Log-Name` a log name for retriving, for example "db3_db:eth:0x123....FE.gz.log"

#### 1.2 Transaction Body Format

This format for the transaction body is binary data in the following bytes format

| Field                | Description                                    | Encoding | Length (in bytes)         | Optional           |
| -------------------  | ---------------------------------------------- | -------- | ------------------------- | ------------------ |
| header               | a static word `AR-LOG`                         | Binary   | 1                         | :x:                |
| first_tx             | the first transaction of log file              | Binary   | 1                         | :x:                |
| parent_tx            | the parent tx of log trunk                     | Binary   | 20                        | :x:                |
| parent_log_trunk_hash| the parent hash of log trunk                   | Binary   | 20                        | :x:                |
| log_trunk_hash       | the hash of log trunk                          | Binary   | 20                        | :x:                |
| log_root_hash        | the root hash of log file                      | Binary   | 20                        | :x:                |
| offset               | the offset of log trunk                        | Binary   | 8                         | :x:                |
| log_trunk_size       | the size of log trunk                          | Binary   | 4                         | :x:                |
| log_total_size       | the total size of log file                     | Binary   | 8                         | :x:                |
| data                 | The log trunk content based on avro format     | Binary   | Variable                  | :x:                |

### 2. DataItem signature and id

The signature and id for a DataItem is built in a manner similar to Arweave 2.0 transaction signing. It uses the Arweave
2.0 deep-hash algorithm. The 2.0 deep-hash algorithm operates on arbitrarily nested arrays of binary data, i.e a
recursive type of `DeepHashChunk = Uint8Array | DeepHashChunk[]`.

There are reference implementations for the deep-hash algorithm
in [TypeScript](https://github.com/ArweaveTeam/arweave-js/blob/b1c4b2e378a1eb7dc1fbfaeee41492eb908a60c6/src/common/lib/deepHash.ts)
and [Erlang](https://github.com/ArweaveTeam/arweave/blob/b316173cd42a53a59036241f8e164b615db9b40d/apps/arweave/src/ar_deep_hash.erl)

To generate a valid signature for a DataItem, the contents of the DataItem and static version tags are passed to the
deep-hash algorithm to obtain a message. This message is signed by the owner of the DataItem to produce the signature.
The id of the DataItem, is the SHA256 digest of this signature.

The exact structure and content passed into the deep-hash algorithm to obtain the message to sign is as follows:

```
[
  utf8Encoded("dataitem"),
  utf8Encoded("1"),
  owner,
  target,
  anchor,
  [
    ... [ tag.name, tag.value ],
    ... [ tag.name, tag.value ],
    ...
  ],
  data
]
```

#### 2.1 Verifying a DataItem

DataItem verification is a key to maintaining consistency within the bundle standard. A DataItem is valid iff.<sup>1</sup>:

- id matches the signature (via SHA-256 of the signature)
- signature matches the owner's public key
- tags are all valid
- an anchor isn't more than 32 bytes

A tag object is valid iff.:

- there are <= 128 tags
- each key is <= 1024 bytes
- each value is <= 3072 bytes
- only contains a key and value
- both the key and value are non-empty strings

### 3. Writing a Bundle of DataItems

To write a bundle of DataItems, each DataItem should be constructed, signed, encoded, and placed in a transaction with
the transaction body format and transaction tags specified in Section 1.

#### 3.1 Nested bundle

Arweave Transactions and DataItems have analogous specifications for tagging and bearing of a binary payload. As such, the ANS-104 Bundle Transaction tagging and binary data format specification can be applied to the tags and binary data payload of a DataItem. Assembling a DataItem this way provides for the nesting of ANS-104 Bundles with one-to-many relationships between "parent" and "child" bundles and theoretically unbounded levels of nesting. Additionally, nested DataItem Bundles can be mixed heterogeneously with non-Bundle DataItems at any depth in the Bundle tree.

To construct an ANS-104 DataItem as a nested Bundle:

- Add tags to the DataItem as described by the specification in [section 1.1](#11-transaction-tags)
- Provide a binary payload for the DataItem matching the Bundle Transaction Body Format described in [section 1.2](#12-transaction-body-format), i.e. the Bundle header outlining the count, size, and IDs of the subsequent, nested DataItems, each of which should be verifiable using the method described in [section 2.1](#21-verifying-a-dataitem).

Gateway GQL queries for DataItem headers should, upon request, contain a `bundledIn` field whose value indicates
the parent-child relationship of the DataItem to its immediate parent. Any nested bundle should be traceable to a base layer Arweave Transaction by recursively following the bundledIn field up through the chain of parents.

### 4. Reading a Bundle of DataItems

To read a bundle of DataItems, the list of bytes representing the DataItems can be partitioned using the offsets in each
pair. Subsequently, each partition can be parsed to a DataItem object (`struct` in languages such as Rust/Go etc.
or `JSON` in TypeScript).

This allows for querying of a singleton or a bundle as a whole.

#### 4.1 Indexing DataItems

This format allows for indexing of specific fields in `O(N)` time. Some form of caching or indexing could be performed
by gateways to improve lookup times.

<sup>1 - if and only if</sup>
